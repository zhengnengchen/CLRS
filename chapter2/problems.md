# 2-1
> Although merge sort runs in ![equation](https://latex.codecogs.com/svg.latex?%5Ctheta%28n%5Clg%7Bn%7D%29) worst-case time and insertion sort runs in ![equation](https://latex.codecogs.com/svg.latex?%5Ctheta%28n%5E2%29) worst-case time, the constant factors in insertion sort can make it faster in practice for small problem sizes on many machines. Thus, it makes sense to **coarsen** the leaves of the recursion by using insertion sort within merge sort when subproblems become sufficiently small. Consider a modification to merge sort in which ![equation](https://latex.codecogs.com/svg.latex?%5Cdfrac%7Bn%7D%7Bk%7D) sublists of length k are sorted using insertion sort and then merged using the standard merging mechanism, where k is a value to be determined.

> a. Show that insertion sort can sort the ![equation](https://latex.codecogs.com/svg.latex?%5Cdfrac%7Bn%7D%7Bk%7D) sublists, each of length k, in ![equation](https://latex.codecogs.com/svg.latex?%5Ctheta%28nk%29) worst-case time.

For each sublist in size of k, insertion sort can sort it in ![equation](https://latex.codecogs.com/svg.latex?%5Ctheta%28k%5E2%29) time and there are ![equation](https://latex.codecogs.com/svg.latex?%5Cdfrac%7Bn%7D%7Bk%7D) of such sublists. Hence, the total time to sort ![equation](https://latex.codecogs.com/svg.latex?%5Cdfrac%7Bn%7D%7Bk%7D) sublists in size of k is ![equation](https://latex.codecogs.com/svg.latex?%5Ctheta%28k%5E2%29%5Ccdot%5Cdfrac%7Bn%7D%7Bk%7D%3D%5Ctheta%28k%5E2%5Ccdot%5Cdfrac%7Bn%7D%7Bk%7D%29%3D%5Ctheta%28nk%29)

> b. Show how to merge the sublists in ![equation](https://latex.codecogs.com/svg.latex?%5Ctheta%28n%5Clg%28%5Cdfrac%7Bn%7D%7Bk%7D%29%29) worst-case time.

We can firstly merge every two sublist into one larger sublist using the standard **merge** procedure. That is, merge ![equation](https://latex.codecogs.com/svg.latex?%5Cdfrac%7Bn%7D%7Bk%7D) sublists into ![equation](https://latex.codecogs.com/svg.latex?%5Cdfrac%7Bn%7D%7B2k%7D) sublists. Repeating this step by merge every two sublists into one until there is only one list that is the original list. According to Figure 2.5, there are ![equation](https://latex.codecogs.com/svg.latex?%5Clg%28%5Cdfrac%7Bn%7D%7Bk%7D%29&plus;1) levels of recurrence. Each level takes ![equation](https://latex.codecogs.com/svg.latex?%5Ctheta%28%5Cdfrac%7Bn%7D%7B2%5Eik%7D%29%5Ccdot2%5E%7Bi-1%7Dk%3D%5Ctheta%28%5Cdfrac%7Bn%7D%7B2%7D%29) time to merge every two sublists into one. Thus, the overall time to merge all sublists into one original list is ![equation](https://latex.codecogs.com/svg.latex?%5Ctheta%28%5Cdfrac%7Bn%7D%7B2%7D%29%5Ccdot%28%5Clg%28%5Cdfrac%7Bn%7D%7Bk%7D%29&plus;1%29%3D%5Ctheta%28n%5Clg%28%5Cdfrac%7Bn%7D%7Bk%7D%29%29)

> c. Given that the modified algorithm runs in ![equation](https://latex.codecogs.com/svg.latex?%5Ctheta%28nk&plus;n%5Clg%28%5Cdfrac%7Bn%7D%7Bk%7D%29%29) worst-case time, what is the largest value of k as a function of n for which the modified algorithm has the same running time as standard merge sort, in terms of ![equation](https://latex.codecogs.com/svg.latex?%5Ctheta)-notation?

Given the worst-case running time of **merge sort** is ![equation](https://latex.codecogs.com/svg.latex?%5Ctheta%28n%5Clg%7Bn%7D%29). We have ![equation](https://latex.codecogs.com/svg.latex?%5Ctheta%28nk&plus;n%5Clg%28%5Cdfrac%7Bn%7D%7Bk%7D%29%29%3D%5Ctheta%28n%5Clg%7Bn%7D%29). Since the modification requires ![equation](https://latex.codecogs.com/svg.latex?k%20%3E%201) to be meaningful, we can ignore the ![equation](https://latex.codecogs.com/svg.latex?n%5Clg%28%5Cdfrac%7Bn%7D%7Bk%7D%29) part on LHS because ![equation](https://latex.codecogs.com/svg.latex?k%20%3E%201) makes ![equation](https://latex.codecogs.com/svg.latex?n%5Clg%28%5Cdfrac%7Bn%7D%7Bk%7D%29%5Cll%20n%5Clg%7Bn%7D). This gives us ![equation](https://latex.codecogs.com/svg.latex?nk%3Dn%5Clg%7Bn%7D%5Cto%20k%3D%5Clg%7Bn%7D).

> d. How should we choose k in practice?

Given the result calculated in previous. We should choose k to be the nearest integer of ![equation](https://latex.codecogs.com/svg.latex?%5Clg%7Bn%7D) where n is the size of array to be sorted.
